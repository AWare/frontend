import collection.Seq
import com.google.common.io.Files
import com.typesafe.sbtscalariform.ScalariformPlugin
import java.io.{FileInputStream, FileOutputStream, FileWriter, File}
import java.security.MessageDigest
import java.util.Properties
import sbt._
import Keys._
import PlayProject._
import sbtassembly.Plugin._
import AssemblyKeys._
import collection.JavaConversions._

object FrontendArticle extends Build {

  private val appName = "frontend-article"
  private val appVersion = "1-SNAPSHOT"

  private val staticPathsFile = SettingKey[File]("static-paths-file",
    "The location of the file that static paths are generated in")

  private val appDependencies = Seq(
    //dependencies included in distribution
    "com.gu.openplatform" %% "content-api-client" % "1.13",
    "com.gu" %% "configuration" % "3.6",
    "com.gu" %% "management-play" % "5.7",
    "com.gu" %% "management-logback" % "5.7",

    //dependencies in test only
    "org.scalatest" %% "scalatest" % "1.7.1" % "test"
  )

  val main = PlayProject(appName, appVersion, appDependencies, mainLang = SCALA)
    .settings(ScalariformPlugin.settings ++ assemblySettings: _*)
    .settings(
    resolvers += "Guardian Github Releases" at "http://guardian.github.com/maven/repo-releases",
    // Disable Specs options to use ScalaTest
    testOptions in Test := Nil,
    organization := "com.gu",
    scalaVersion := "2.9.1",
    maxErrors := 20,
    javacOptions ++= Seq("-source", "1.6", "-target", "1.6", "-encoding", "utf8"),
    scalacOptions ++= Seq("-unchecked", "-optimise", "-deprecation", "-Xcheckinit", "-encoding", "utf8"),

    mainClass in assembly := Some("play.core.server.NettyServer"),
    jarName in assembly := "%s.jar" format appName,
    test in assembly := {},
    excludedFiles in assembly := {
      (base: Seq[File]) =>
        ((base / "logger.xml") +++ (base / "META-INF" / "MANIFEST.MF")).get
    },
    resourceGenerators in Compile <+= staticFileUrlGenerator,
    staticPathsFile in Compile <<= (resourceManaged in Compile) / "static-paths.properties",
    dist <<= myDistTask
  )

  val LessFile = """(.*)\.less$""".r
  val CoffeeFile = """(.*)\.coffee$""".r
  val JavaScriptFile = """(.*)\.js$""".r

  private def staticFileUrlGenerator =
    (baseDirectory , lessEntryPoints, coffeescriptEntryPoints, streams, staticPathsFile in Compile).map {

      (base, lessFiles, coffeeFiles, s, pathsFile) => {
        val log = s.log

        log.info("Generating static file paths to %s" format pathsFile)
        val assetsDir = (base / "app" / "assets")

        val resourceFiles = lessFiles.get ++ coffeeFiles.get


        val hashedResourceFiles = resourceFiles.par.flatMap(f => f.relativeTo(assetsDir).map((digestFor(f), _)))

        val generatedPaths = hashedResourceFiles flatMap {
          case (hash, file) =>
            file.getPath match {
              case LessFile(name) => List((name + ".css", name + "." + hash + ".css"),
                (name + ".min.css", name + "." + hash + ".min.css"))
              case CoffeeFile(name) => List((name + ".js", name + "." + hash + ".js"),
                (name + ".min.js", name + "." + hash + ".min.js"))
              case JavaScriptFile(name) => List((name + ".js", name + "." + hash + ".js"),
                (name + ".min.js", name + "." + hash + ".min.js"))
              case _ => sys.error("Do not understand resource file: " + name)
            }
        }

        val publicDir = (base / "public")

        val publicPaths = (publicDir ** ("**")).get.par.filter(!_.isDirectory).flatMap {
          file: File =>
            val hash = digestFor(file)
            file.relativeTo(publicDir).map(_.getPath).toList.map {
              path =>
                val pathParts = path.split("""\.""")
                (path, (pathParts.dropRight(1) ++ List(hash) ++ pathParts.takeRight(1)).mkString("."))
            }
        }

        if (pathsFile.exists) pathsFile.delete

        pathsFile.getParentFile.mkdirs()
        pathsFile.createNewFile()

        val out = new FileOutputStream(pathsFile)

        val props = new Properties()
        (generatedPaths ++ publicPaths).foreach {
          case (key, value) =>
            props.setProperty(key, value)
        }
        props.store(out, "Generated by sbt build, do not modify")
        out.close()

        log.info("Done generating static paths file")
        Seq(pathsFile)
      }
    }

  private def digestFor(file: File): String = Hash.toHex(Files.getDigest(file, MessageDigest.getInstance("MD5")))

  private def loadPropertiesFile(staticPaths: File) = {
    val props = new Properties()
    val stream: FileInputStream = new FileInputStream(staticPaths)
    props.load(stream)
    stream.close()
    props
  }

  def myDistTask =
    (assembly, streams, baseDirectory, target, resourceManaged in Compile, staticPathsFile in Compile) map {
      (jar, s, baseDir, outDir, resourcesDir, staticPaths) => {
        val log = s.log

        val distFile = outDir / "artifacts.zip"
        log.info("Disting %s ..." format distFile)

        if (distFile exists) { distFile delete() }


        val props =loadPropertiesFile(staticPaths)

        val cacheBustedResources = props.stringPropertyNames.map{ propName =>
          (propName, props.getProperty(propName))
        }

        val resourceAssetsDir = resourcesDir / "public"
        val resourceAssets = cacheBustedResources map { case (key, cachedKey) =>
          (resourceAssetsDir / key, cachedKey)
        } filter { fileExists }

        val publicAssetsDir = baseDir / "public"
        val publicAssets = cacheBustedResources map { case (key, cachedKey) =>
          (publicAssetsDir / key, cachedKey)
        } filter { fileExists }


        val staticFiles = (resourceAssets ++ publicAssets) map { case (file, cachedKey) =>
          val locationInZip = "packages/%s/static-files/%s".format(appName, cachedKey)
          log.verbose("Static file %s -> %s" format (file, locationInZip))
          (file, locationInZip)
        }

        val filesToZip = Seq(
          baseDir / "conf" / "deploy.json" -> "deploy.json",
          jar -> "packages/%s/%s".format(appName, jar.getName)
        ) ++ staticFiles


        IO.zip(filesToZip, distFile)

        //tells TeamCity to publish the artifact => leav this println in here
        println("##teamcity[publishArtifacts '%s => .']" format distFile)

        log.info("Done disting.")
        jar
      }
    }

  private def fileExists(f: (File, String)) = f._1.exists()
}
